package main

import (
	"compiler/errors"
	parser "compiler/parser"
	"fmt"

	// "go/ast"
	"io/ioutil"
	"strings"

	"compiler/ast"

	// "compiler/semantic"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	"github.com/antlr4-go/antlr/v4"
)

type LineNumberedEditor struct {
	widget.BaseWidget
	entry       *widget.Entry
	lineNumbers *widget.Label
	container   *fyne.Container
}

// NewLineNumberedEditor crea una nueva instancia del editor con n√∫meros de l√≠nea
func NewLineNumberedEditor() *LineNumberedEditor {
	editor := &LineNumberedEditor{}
	editor.ExtendBaseWidget(editor)

	// Crear el editor de texto
	editor.entry = widget.NewMultiLineEntry()
	editor.entry.Wrapping = fyne.TextWrapOff // Desactivar wrap para mejor alineaci√≥n
	editor.entry.SetPlaceHolder("// Escribe tu c√≥digo V-Lang Cherry aqu√≠...")

	// Crear el widget de n√∫meros de l√≠nea usando Label simple
	editor.lineNumbers = widget.NewLabel("1")
	editor.lineNumbers.Alignment = fyne.TextAlignTrailing // Alinear a la derecha

	// Configurar el callback para actualizar los n√∫meros cuando el texto cambie
	editor.entry.OnChanged = func(text string) {
		editor.updateLineNumbers(text)
	}

	// Configurar tama√±o fijo para los n√∫meros de l√≠nea
	editor.lineNumbers.Resize(fyne.NewSize(60, 0)) // Ancho fijo de 60 p√≠xeles

	// Crear el contenedor usando Border para mejor control de tama√±o
	editor.container = container.NewBorder(
		nil, nil, // top, bottom
		editor.lineNumbers, nil, // left, right
		editor.entry, // center (toma el espacio restante)
	)

	// Inicializar con la primera l√≠nea
	editor.updateLineNumbers("")

	return editor
}

// updateLineNumbers actualiza los n√∫meros de l√≠nea bas√°ndose en el contenido
func (e *LineNumberedEditor) updateLineNumbers(text string) {
	lines := strings.Split(text, "\n")
	if len(lines) == 0 {
		lines = []string{""}
	}

	// Construir los n√∫meros de l√≠nea
	var lineNumbers []string
	for i := 1; i <= len(lines); i++ {
		lineNumbers = append(lineNumbers, fmt.Sprintf("%3d", i))
	}

	// Actualizar el label de n√∫meros de l√≠nea
	numbersText := strings.Join(lineNumbers, "\n")
	e.lineNumbers.SetText(numbersText)
}

// CreateRenderer implementa la interfaz fyne.Widget
func (e *LineNumberedEditor) CreateRenderer() fyne.WidgetRenderer {
	return widget.NewSimpleRenderer(e.container)
}

// M√©todos para exponer la funcionalidad del Entry subyacente
func (e *LineNumberedEditor) SetText(text string) {
	e.entry.SetText(text)
}

func (e *LineNumberedEditor) Text() string {
	return e.entry.Text
}

func (e *LineNumberedEditor) SetPlaceHolder(placeholder string) {
	e.entry.SetPlaceHolder(placeholder)
}

func (e *LineNumberedEditor) Disable() {
	e.entry.Disable()
}

func (e *LineNumberedEditor) Enable() {
	e.entry.Enable()
}

// M√©todo para establecer callback de cambio de texto
func (e *LineNumberedEditor) OnChanged(callback func(string)) {
	originalCallback := e.entry.OnChanged
	e.entry.OnChanged = func(text string) {
		originalCallback(text) // Mantener la actualizaci√≥n de n√∫meros
		if callback != nil {
			callback(text) // Llamar al callback personalizado
		}
	}
}

type IDE struct {
	window      fyne.Window
	codeEditor  *LineNumberedEditor // Cambiar de codeEntry a codeEditor
	outputEntry *widget.Entry
	currentFile string
	app         fyne.App
	// Componentes para reportes
	errorTable  *errors.ErrorTable
	symbolTable interface{}
	astRoot     ast.Node
}

func main() {
	a := app.NewWithID("com.vlang.ide")
	w := a.NewWindow("üçí V-Lang Cherry IDE")

	ide := &IDE{
		window: w,
		app:    a,
	}

	content := ide.createMainContent()
	mainMenu := ide.createMenu()
	w.SetMainMenu(mainMenu)

	w.SetContent(content)
	w.Resize(fyne.NewSize(1000, 700))
	w.CenterOnScreen()
	w.ShowAndRun()
}

func (ide *IDE) createMainContent() fyne.CanvasObject {
	// Usar el nuevo editor con n√∫meros de l√≠nea
	ide.codeEditor = NewLineNumberedEditor()

	// Consola de salida (mantener como est√°)
	ide.outputEntry = widget.NewMultiLineEntry()
	ide.outputEntry.Wrapping = fyne.TextWrapWord
	ide.outputEntry.Disable()

	// Tabs
	tabs := container.NewAppTabs(
		container.NewTabItem("üìù Editor", container.NewVScroll(ide.codeEditor)),
		container.NewTabItem("üñ•Ô∏è Consola", container.NewVScroll(ide.outputEntry)),
	)

	// Toolbar
	toolbar := ide.createToolbar()

	return container.NewBorder(toolbar, nil, nil, nil, tabs)
}
func (ide *IDE) createMenu() *fyne.MainMenu {
	// Men√∫ Archivo
	fileMenu := fyne.NewMenu("Archivo",
		fyne.NewMenuItem("Nuevo", func() { ide.newFile() }),
		fyne.NewMenuItem("Abrir...", func() { ide.openFile() }),
		fyne.NewMenuItemSeparator(),
		fyne.NewMenuItem("Guardar", func() { ide.saveFile() }),
		fyne.NewMenuItem("Guardar como...", func() { ide.saveFileAs() }),
	)

	// Men√∫ Herramientas
	toolsMenu := fyne.NewMenu("Herramientas",
		fyne.NewMenuItem("Ejecutar", func() { ide.runCode() }),
	)

	// Men√∫ Reportes - ahora con todos los m√©todos implementados
	reportsMenu := fyne.NewMenu("Reportes",
		fyne.NewMenuItem("Reporte de Errores", func() { ide.showErrorsReport() }),
		fyne.NewMenuItem("Tabla de S√≠mbolos", func() { ide.showSymbolTableReport() }),
		fyne.NewMenuItem("Reporte AST", func() { ide.showASTReport() }),
	)

	return fyne.NewMainMenu(fileMenu, toolsMenu, reportsMenu)
}

func (ide *IDE) createToolbar() fyne.CanvasObject {
	runBtn := widget.NewButtonWithIcon("Ejecutar", theme.MediaPlayIcon(), func() {
		ide.runCode()
	})
	runBtn.Importance = widget.HighImportance

	return container.NewHBox(runBtn)
}

// Funciones de archivo
func (ide *IDE) newFile() {
	ide.codeEditor.SetText("")
	ide.currentFile = ""
	ide.outputEntry.SetText("")
}

func (ide *IDE) openFile() {
	dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		data, err := ioutil.ReadAll(reader)
		if err != nil {
			dialog.ShowError(err, ide.window)
			return
		}

		ide.codeEditor.SetText(string(data))
		ide.currentFile = reader.URI().Path()
	}, ide.window)
}

func (ide *IDE) saveFile() {
	if ide.currentFile == "" {
		ide.saveFileAs()
		return
	}

	err := ioutil.WriteFile(ide.currentFile, []byte(ide.codeEditor.Text()), 0644)
	if err != nil {
		dialog.ShowError(err, ide.window)
	}
}

func (ide *IDE) saveFileAs() {
	dialog.ShowFileSave(func(writer fyne.URIWriteCloser, err error) {
		if err != nil || writer == nil {
			return
		}
		defer writer.Close()

		_, err = writer.Write([]byte(ide.codeEditor.Text()))
		if err != nil {
			dialog.ShowError(err, ide.window)
			return
		}

		ide.currentFile = writer.URI().Path()
	}, ide.window)
}

func (ide *IDE) runCode() {
	code := ide.codeEditor.Text()
	ide.outputEntry.SetText("üîÑ Compilando...\n\n")

	// === FASE 1: AN√ÅLISIS L√âXICO ===
	lexicalErrs := errors.NewLexicalErrorListener()
	lexer := parser.NewVlangLexer(antlr.NewInputStream(code))
	lexer.RemoveErrorListeners()
	lexer.AddErrorListener(lexicalErrs)
	tokens := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

	// === FASE 2: AN√ÅLISIS SINT√ÅCTICO ===
	p := parser.NewVlangParser(tokens)
	p.BuildParseTrees = true
	syntaxErrs := errors.NewSyntaxErrorListener(lexicalErrs.ErrorTable)
	p.RemoveErrorListeners()
	p.AddErrorListener(syntaxErrs)
	tree := p.Programa()

	ide.errorTable = lexicalErrs.ErrorTable

	if ide.errorTable.HasErrors() {
		ide.showErrors()
		return
	}

	ide.outputEntry.SetText("‚úÖ An√°lisis l√©xico y sint√°ctico completado\n")

	// === FASE 3: CONSTRUCCI√ìN DEL AST ===
	ide.outputEntry.SetText(ide.outputEntry.Text + "üî® Construyendo AST...\n")

	astBuilder := NewASTBuilder()
	astProgram, err := astBuilder.Build(tree)

	if err != nil {
		ide.outputEntry.SetText(ide.outputEntry.Text + fmt.Sprintf("‚ùå Error al construir el AST: %v\n", err))
		return
	}

	// NUEVO: Realizar an√°lisis sem√°ntico
	semanticAnalyzer := ast.NewSemanticAnalyzer()
	err = semanticAnalyzer.Analyze(astProgram)
	if err != nil {
		// Imprimir errores sem√°nticos
		for _, e := range semanticAnalyzer.GetSymbolTable().GetErrors() {
			fmt.Println("Semantic Error:", e)
		}
		ide.outputEntry.SetText(ide.outputEntry.Text + fmt.Sprintf("‚ùå Error: %v\n", err))
	}

	// Imprimir tabla de s√≠mbolos (opcional, para debug)
	semanticAnalyzer.GetSymbolTable().PrintTable()

	ide.outputEntry.SetText(ide.outputEntry.Text + "‚úÖ AST construido exitosamente\n")

	// === FASE 4: INTERPRETACI√ìN ===
	ide.outputEntry.SetText(ide.outputEntry.Text + "\nüöÄ Ejecutando programa...\n")
	ide.outputEntry.SetText(ide.outputEntry.Text + "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")

	interpreter := ast.NewInterpreter()
	output, err := interpreter.Interpret(astProgram)

	if err != nil {
		errorMsg := fmt.Sprintf("‚ùå Error durante la ejecuci√≥n: %v\n", err)
		ide.outputEntry.SetText(ide.outputEntry.Text + errorMsg)
		fmt.Print(errorMsg) // Tambi√©n mostrar en terminal
		ide.outputEntry.SetText(ide.outputEntry.Text + "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
		return
	}

	ide.outputEntry.SetText(ide.outputEntry.Text + output)
	fmt.Print(output)
	ide.outputEntry.SetText(ide.outputEntry.Text + "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n")
	ide.outputEntry.SetText(ide.outputEntry.Text + "‚úÖ Ejecuci√≥n completada\n")
}

func (ide *IDE) showErrors() {
	var output strings.Builder
	output.WriteString("‚ùå Se encontraron errores:\n\n")

	for i, err := range ide.errorTable.Errors {
		output.WriteString(fmt.Sprintf("[%d] %s\n", i+1, err.String()))
	}

	ide.outputEntry.SetText(output.String())
}

func (ide *IDE) showErrorsReport() {
	if ide.errorTable == nil || !ide.errorTable.HasErrors() {
		dialog.ShowInformation("Reporte de Errores",
			"No hay errores para mostrar", ide.window)
		return
	}

	ide.showErrors()
}

func (ide *IDE) showASTReport() {
	if ide.astRoot == nil {
		dialog.ShowInformation("Reporte AST",
			"No hay AST disponible. Ejecuta el c√≥digo primero.", ide.window)
		return
	}

	if ide.astRoot == nil {
		fmt.Println("AST es nil")
		return
	}

	// Imprimir tipo del nodo ra√≠z
	fmt.Printf("AST Root Type: %T\n", ide.astRoot)

	// Si es un Program, imprimir el n√∫mero de statements
	if program, ok := ide.astRoot.(*ast.Program); ok {
		fmt.Printf("Program tiene %d statements\n", len(program.Statements))
		for i, stmt := range program.Statements {
			fmt.Printf("  Statement %d: %T\n", i, stmt)
		}
	}

	// Generar el reporte del AST
	// html := reports.GenerateASTReport(ide.astRoot)

	// // Guardar el archivo HTML
	// filename := "ast_report.html"
	// reports.SaveAndOpenReport(html, filename)

	// // Opcionalmente, generar imagen con Graphviz
	// dot := reports.GenerateASTDot(ide.astRoot)
	// reports.GenerateASTImage(dot, "ast_graph.png")

	// dialog.ShowInformation("Reporte AST",
	// 	"Reporte generado exitosamente en "+filename, ide.window)
}

func (ide *IDE) showSymbolTableReport() {
	if ide.symbolTable == nil {
		dialog.ShowInformation("Tabla de S√≠mbolos",
			"No hay tabla de s√≠mbolos disponible. Ejecuta el c√≥digo primero.", ide.window)
		return
	}

	// Por ahora, mostrar un mensaje simple
	dialog.ShowInformation("Tabla de S√≠mbolos",
		"Generaci√≥n de tabla de s√≠mbolos en desarrollo...", ide.window)

	// TODO: Cuando tengas el analizador sem√°ntico listo:
	// html := reports.GenerateSymbolTableReport(ide.symbolTable)
	// reports.SaveAndOpenReport(html, "symbol_table_report.html")
}

func (ide *IDE) debugPrintAST() {
	if ide.astRoot == nil {
		fmt.Println("AST es nil")
		return
	}

	// Imprimir tipo del nodo ra√≠z
	fmt.Printf("AST Root Type: %T\n", ide.astRoot)

	// Si es un Program, imprimir el n√∫mero de statements
	if program, ok := ide.astRoot.(*ast.Program); ok {
		fmt.Printf("Program tiene %d statements\n", len(program.Statements))
		for i, stmt := range program.Statements {
			fmt.Printf("  Statement %d: %T\n", i, stmt)
		}
	}
}
